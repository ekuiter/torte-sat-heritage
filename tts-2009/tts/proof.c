#include <string.h>


#include "proof.h"
#include "tts.h"
#include "ternarytree.h"
#include "set.h"
#include "intset.h"
#include "dimacs.h"
#include "cbigopen.h"
#include "options.h"

FILE *proofFile;
FILE *rptFile;
FILE *traceFile;

long int nextResId;

int amLittleEndian;

int *setIdToResId=NULL;
int maxAllocatedSetToResId = -1;

void assignSetIdToResId (int setId, int resId)
{
	if (booleanOptions[TRACE_RESOLUTIONS])
		fprintf (traceFile, "set %d -> res %d\n", setId, resId);
	if (setId > maxAllocatedSetToResId)
	{
		maxAllocatedSetToResId = ( setId/1000 + 1) * 1000;
		setIdToResId = (int *) checkRealloc (setIdToResId, (maxAllocatedSetToResId+1)*sizeof(int),"");
	}
	setIdToResId[setId] = resId;
}

void setAmLittleEndian()
{
	unsigned char *x;
	unsigned int i;

	i = 1;
	x = (unsigned char *) &i;

	amLittleEndian = x[0] == 1;
}

void openRPTFile (char *proofFileName)
{
	char header[256], numbers[33];
	int i;

	setAmLittleEndian();

	rptFile = cBigOpenW (proofFileName);
	if (rptFile == NULL)
	{
		fprintf (stderr, "Could not open %s for writing\n",proofFileName);
		exit(0);
	}

	sprintf (numbers, " %d %d ", dimacsVariables, dimacsClauses);
	for (i=strlen(numbers);i<32;i++)
		numbers[i] = ' ';
	numbers[32] = '\0';

	sprintf (header, "%cRPT%c32%s%s", '%', amLittleEndian?'L':'B',numbers, "Proof generated by ttsp");
	fprintf (rptFile, "%s", header);
	for (i=strlen(header);i<255;i++)
		fprintf (rptFile, " ");
	fprintf (rptFile, "\n");
}

void sendLongInt (FILE *f, int i)
{
	fwrite (&i, 1, sizeof(int), f);
}


void resolveProofClauses (long int variable,long int clause1, long int clause2, long int result)
{

		sendLongInt (rptFile, result);
		sendLongInt (rptFile, variable);

		sendLongInt (rptFile, clause1);
		sendLongInt (rptFile, clause2);
		
		if (booleanOptions[TRACE_RESOLUTIONS])
			fprintf (traceFile,"%ld = (%ld %ld) %ld + %ld\n", result, globalTransform[variable], variable, clause1, clause2);
		//printIntSet (resolvents[result]); printf (" "); printIntSet (resolvents[clause1]); printf (" ");printIntSet (resolvents[clause2]); printf ("\n");
}


void openProofFile ()
{
	
	char *extension = ".prt";
	char *rptextension = ".rpt";
	char *traceextension = ".trace";
	
	char *rptfilename = (char *) checkMalloc ((strlen(dimacsBaseName)+strlen(rptextension)+1)*sizeof(char),"");
	char *filename = (char *) checkMalloc ((strlen(dimacsBaseName)+strlen(extension)+1)*sizeof(char),"");
	char *tracefilename = (char *) checkMalloc ((strlen(dimacsBaseName)+strlen(traceextension)+1)*sizeof(char),"");
	
		
	if (booleanOptions[PRT_FILE])
	{
		strcpy (filename, dimacsBaseName);
		strcat (filename, extension);
		proofFile = cBigOpenW (filename);
		if (proofFile == NULL)
		{
			fprintf (stderr, "Could not open proof file %s for writing\n", filename);
			exit(0);
		}
	}

/*
	fprintf (proofFile, "%d ", maxVariable);
	for (v=1;v<=maxVariable;v++)
		fprintf (proofFile, " %d", globalUnTransform[v]);
	fprintf (proofFile,"\n");
*/    

	if (booleanOptions[RPT_FILE])
	{
		strcpy (rptfilename, dimacsBaseName);
		strcat (rptfilename, rptextension);
		openRPTFile (rptfilename);
	}  
	if (booleanOptions[TRACE_RESOLUTIONS])
	{
		strcpy (tracefilename, dimacsBaseName);
		strcat (tracefilename, traceextension);
		traceFile = cBigOpenW (tracefilename);
		if (traceFile == NULL)
		{
			fprintf (stderr, "Could not open proof file %s for writing\n", tracefilename);
			exit(0);
		}
	}
	
	free(filename);
	free(rptfilename);
	free(tracefilename);
	
	nextResId = dimacsClauses+1;
}


void printFalseSet (SetPtr s)
{
	int l;
	TernaryTreePtr n;
	for (l=0;l<s->numOfElements;l++)
	{
		n = (TernaryTreePtr)s->elements[l];
		fprintf (proofFile, "%d ", n->id);
	}
	fprintf (proofFile, "0");
}

void printResolution (int variable, int left, int right, int super, SetPtr s)
{
	fprintf (proofFile, "%d %d %d %d %d ", RESOLVEPROPOSITION, globalUnTransform[variable], right, left, super);
	printFalseSet (s);
	fprintf (proofFile,"\n");
}
void printSuper (int sub, int super, SetPtr s)
{
	fprintf (proofFile, "%d %d %d ", SUPERSETPROPOSITION, sub, super);
	printFalseSet (s);
	fprintf (proofFile,"\n");
}

void printVarSet (FILE *proofFile, IntSetPtr set)
{
	int i,v,av;
	
	for (i=0;i<set->numOfElements;i++)
	{
		av = set->elements[i];
		v = (av > 0) ? globalUnTransform[av]: -globalUnTransform[-av];
		fprintf (proofFile, " %d", v);
	}
	fprintf (proofFile, " 0");
}

void printNodeLinks (TernaryTreePtr node)
{
	fprintf (proofFile, "%d %d %d %d", LINKVAR, globalUnTransform[node->firstVar], node->right->id, node->id);
	if (booleanOptions[RPT_FILE] && node->right->id == 0)
		printVarSet (proofFile, node->right->originalVariables);
	fprintf (proofFile, "\n");
	fprintf (proofFile, "%d %d %d %d", LINKVAR, -globalUnTransform[node->firstVar], node->left->id, node->id);
	if (booleanOptions[RPT_FILE] && node->left->id == 0)
		printVarSet (proofFile, node->left->originalVariables);
	fprintf (proofFile, "\n");
	fprintf (proofFile, "%d %d %d\n", LINKDIRECT, node->both->id, node->id);
}

int nextNodeId = 2;

void assignNodeIds (TernaryTreePtr node)
{
	if (node->id == -1)
	{
		assignNodeIds (node->left);
		assignNodeIds (node->right);
		assignNodeIds (node->both);
		node->id = nextNodeId++;
		printNodeLinks (node);
	}
}


void closeProofFile(int sat, int id)
{
	int c,i;
	
 
	
	if (booleanOptions[PRT_FILE])
	{
		if (!sat)
			fprintf (proofFile,"%d %d\n", ASSERTANSWER, id);
		fclose(proofFile);
	}
	if (booleanOptions[RPT_FILE])
	{
		fclose (rptFile);
	}
	if (booleanOptions[TRACE_RESOLUTIONS])
	{
		fclose (traceFile);
	}
}

fpos_t endOfUnitClausesPosition;

void noteEndOfUnitClauses()
{
	fgetpos (rptFile, &endOfUnitClausesPosition);
}
void resetToEndOfUnitClauses()
{
	fsetpos (rptFile, &endOfUnitClausesPosition);
}
